import random

# Function to calculate the number of attacking pairs of queens
def calculate_attacks(board):
    attacks = 0
    n = len(board)
    for i in range(n):
        for j in range(i+1, n):
            if board[i] == board[j] or abs(board[i] - board[j]) == j - i:
                attacks += 1
    return attacks

# Function to generate a random initial board
def generate_initial_state(n):
    return [random.randint(0, n-1) for _ in range(n)]

# Function to display the board
def display_board(board):
    n = len(board)
    for row in range(n):
        line = ""
        for col in range(n):
            if board[col] == row:
                line += "Q "
            else:
                line += ". "
        print(line)
    print()

# Function to get neighbors of a board (move each queen to a different row)
def get_neighbors(board):
    neighbors = []
    n = len(board)
    for col in range(n):
        for row in range(n):
            if row != board[col]:
                new_board = board[:]
                new_board[col] = row
                neighbors.append(new_board)
    return neighbors

# Hill Climbing Algorithm
def hill_climbing(n):
    current_state = generate_initial_state(n)
    current_cost = calculate_attacks(current_state)
    
    print("Initial board:")
    display_board(current_state)
    
    while current_cost > 0:
        neighbors = get_neighbors(current_state)
        best_neighbor = None
        best_cost = current_cost
        
        # Choose neighbor with least attacks
        for neighbor in neighbors:
            neighbor_cost = calculate_attacks(neighbor)
            if neighbor_cost < best_cost:
                best_neighbor = neighbor
                best_cost = neighbor_cost
        
        # No improvement â†’ local optimum
        if best_cost == current_cost:
            break
        
        current_state = best_neighbor
        current_cost = best_cost
        
        print(f"Move to new board with {current_cost} attacks:")
        display_board(current_state)

    if current_cost == 0:
        print("Solution found!")
    else:
        print("Local optimum reached, no perfect solution.")
    
    return current_state, current_cost


# Example usage
if __name__ == "__main__":
    n = 4
    print("Running Hill Climbing for 4-Queens Problem...\n")
    final_state, final_attacks = hill_climbing(n)
    print("Final State:")
    display_board(final_state)
    print("Final number of attacks:", final_attacks)
