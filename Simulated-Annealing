import random
import math

# Function to calculate the number of attacking pairs of queens
def calculate_attacks(board):
    attacks = 0
    n = len(board)
    for i in range(n):
        for j in range(i+1, n):
            if board[i] == board[j] or abs(board[i] - board[j]) == j - i:
                attacks += 1
    return attacks

# Function to generate a random initial board
def generate_initial_state(n):
    return [random.randint(0, n-1) for _ in range(n)]

# Function to display the board
def display_board(board):
    n = len(board)
    for row in range(n):
        line = ""
        for col in range(n):
            if board[col] == row:
                line += "Q "
            else:
                line += ". "
        print(line)
    print()

# Function to get neighbors of a board
def get_neighbors(board):
    neighbors = []
    n = len(board)
    for col in range(n):
        for row in range(n):
            if row != board[col]:
                new_board = board[:]
                new_board[col] = row
                neighbors.append(new_board)
    return neighbors

# Simulated Annealing Algorithm
def simulated_annealing(n, initial_temperature=1000, cooling_rate=0.95, max_iterations=50):
    current_state = generate_initial_state(n)
    current_cost = calculate_attacks(current_state)
    temperature = initial_temperature

    print("Initial board (Simulated Annealing):")
    display_board(current_state)

    for iteration in range(max_iterations):
        if current_cost == 0:
            print("Solution found!")
            break

        neighbors = get_neighbors(current_state)
        best_neighbor = random.choice(neighbors)
        best_cost = calculate_attacks(best_neighbor)
        delta_cost = best_cost - current_cost

        # Accept move if better or with certain probability
        if delta_cost < 0 or random.random() < math.exp(-delta_cost / max(temperature, 1e-10)):
            current_state = best_neighbor
            current_cost = best_cost
            print(f"Move to new board with {current_cost} attacks (iteration {iteration + 1}):")
            display_board(current_state)

        temperature *= cooling_rate

    if current_cost != 0:
        print(f"Finished without finding perfect solution. Final attacks: {current_cost}")
    
    return current_state, current_cost


# Example usage
if __name__ == "__main__":
    n = 4
    print("Running Simulated Annealing for 4-Queens Problem...\n")
    final_state, final_attacks = simulated_annealing(n)
    print("Final State:")
    display_board(final_state)
    print("Final number of attacks:", final_attacks)
